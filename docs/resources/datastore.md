---
layout: ""
page_title: "satori_datstore (Resource)"
description: |-
satori_datastore resource allows defining datastore(s)
---

# satori_datastore (Resource)

Satori provides the ability to connect to broad range of data stores repositories.
The **satori_datastore** resource allows lifecycle management for the datastores.

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- **dataaccess_controller_id** (String) Host FQDN name.
- **hostname** (String) Data provider's FQDN hostname.
- **name** (String) DataStore name.
- **type** (String) The datastore type, for example: POSTGRESQL, SNOWFLAKE, etc. The full list is available at https://app.satoricyber.com/docs/api#post-/api/v1/datastore

### Optional

- **baseline_security_policy** (Block List, Max: 1) Baseline security policy. (see [below for nested schema](#nestedblock--baseline_security_policy))
- **custom_ingress_port** (Number) Custom ingress port number description.
- **databricks_settings** (Block List) Settings for a Databricks Data Store type (see [below for nested schema](#nestedblock--databricks_settings))
- **datastore_settings** (Block List) Settings for a MongoDB Data Store type (see [below for nested schema](#nestedblock--datastore_settings))
- **network_policy** (Block List) A network Policy for a Data Store (see [below for nested schema](#nestedblock--network_policy))
- **origin_port** (Number) Port number description.
- **project_ids** (Set of String) ProjectIds list of project IDs
- **satori_auth_settings** (Block List, Max: 1) Sets the authentication settings for the Data Store (see [below for nested schema](#nestedblock--satori_auth_settings))

### Read-Only

- **id** (String) DataStore resource id.
- **satori_hostname** (String) Satori Hostname.

<a id="nestedblock--baseline_security_policy"></a>
### Nested Schema for `baseline_security_policy`

Required:

- **exclusions** (Block List, Min: 1, Max: 1) Exempt users and patterns from baseline security policy (see [below for nested schema](#nestedblock--baseline_security_policy--exclusions))
- **unassociated_queries_category** (Block List, Min: 1, Max: 1) UnassociatedQueriesCategory (see [below for nested schema](#nestedblock--baseline_security_policy--unassociated_queries_category))
- **unsupported_queries_category** (Block List, Min: 1, Max: 1) UnsupportedQueriesCategory (see [below for nested schema](#nestedblock--baseline_security_policy--unsupported_queries_category))

Optional:

- **type** (String) DataStore security policy. Defaults to `BASELINE_POLICY`.

<a id="nestedblock--baseline_security_policy--exclusions"></a>
### Nested Schema for `baseline_security_policy.exclusions`

Optional:

- **excluded_identities** (Block List) Exempt Users from the Baseline Security Policy (see [below for nested schema](#nestedblock--baseline_security_policy--exclusions--excluded_identities))
- **excluded_query_patterns** (Block List) Exempt Queries from the Baseline Security Policy (see [below for nested schema](#nestedblock--baseline_security_policy--exclusions--excluded_query_patterns))

<a id="nestedblock--baseline_security_policy--exclusions--excluded_identities"></a>
### Nested Schema for `baseline_security_policy.exclusions.excluded_identities`

Optional:

- **identity** (String) Username
- **identity_type** (String) USER type is supported


<a id="nestedblock--baseline_security_policy--exclusions--excluded_query_patterns"></a>
### Nested Schema for `baseline_security_policy.exclusions.excluded_query_patterns`

Optional:

- **pattern** (String) Query pattern



<a id="nestedblock--baseline_security_policy--unassociated_queries_category"></a>
### Nested Schema for `baseline_security_policy.unassociated_queries_category`

Optional:

- **query_action** (String) Default policy action for querying locations that are not associated with a dataset, modes supported:  PASS笏コEDACT笏ィLOCK.


<a id="nestedblock--baseline_security_policy--unsupported_queries_category"></a>
### Nested Schema for `baseline_security_policy.unsupported_queries_category`

Required:

- **query_action** (String) Default policy action for unsupported queries and objects, modes supported:  PASS笏コEDACT笏ィLOCK



<a id="nestedblock--databricks_settings"></a>
### Nested Schema for `databricks_settings`

Required:

- **account_id** (String) Account ID
- **credentials** (Block List, Min: 1) Credentials for Databricks Data Store type (see [below for nested schema](#nestedblock--databricks_settings--credentials))
- **warehouse_id** (String) SQL Warehouse ID

<a id="nestedblock--databricks_settings--credentials"></a>
### Nested Schema for `databricks_settings.credentials`

Required:

- **client_id** (String) Application (client) ID
- **client_secret** (String, Sensitive) Client secret value
- **type** (String) Credentials type, user `AWS_SERVICE_PRINCIPAL_TOKEN` for AWS Service Principal Authentication



<a id="nestedblock--datastore_settings"></a>
### Nested Schema for `datastore_settings`

Optional:

- **aws_hosted_zone_id** (String) MongoDB AWS Hosted Zone ID, The Hosted AWS DNS Zone created for mapping MongoDB SRV records to Satori.
- **aws_service_role_arn** (String) MongoDB AWS Service Role ARN, The IAM role ARN assumed by the DAC and used for updating records in the hosted DNS zone.
- **deployment_type** (String) MongoDB deployment type, for now supports only mongodb+srv and mongodb deployment


<a id="nestedblock--network_policy"></a>
### Nested Schema for `network_policy`

Optional:

- **allowed_rules** (Block List) Allowed Ip Rules (see [below for nested schema](#nestedblock--network_policy--allowed_rules))
- **blocked_rules** (Block List) Blocked Ips Rules (see [below for nested schema](#nestedblock--network_policy--blocked_rules))

<a id="nestedblock--network_policy--allowed_rules"></a>
### Nested Schema for `network_policy.allowed_rules`

Optional:

- **ip_ranges** (Block List) Defines IP addresses or CIDR ranges allowed to access the datastore (see [below for nested schema](#nestedblock--network_policy--allowed_rules--ip_ranges))
- **note** (String) custom description for allowed IP ranges

<a id="nestedblock--network_policy--allowed_rules--ip_ranges"></a>
### Nested Schema for `network_policy.allowed_rules.ip_ranges`

Required:

- **ip_range** (String) Range (IP or CIDR)



<a id="nestedblock--network_policy--blocked_rules"></a>
### Nested Schema for `network_policy.blocked_rules`

Optional:

- **ip_ranges** (Block List) Defines IP addresses or CIDR ranges allowed to access the datastore (see [below for nested schema](#nestedblock--network_policy--blocked_rules--ip_ranges))
- **note** (String) custom description for blocked IP ranges

<a id="nestedblock--network_policy--blocked_rules--ip_ranges"></a>
### Nested Schema for `network_policy.blocked_rules.ip_ranges`

Required:

- **ip_range** (String) Range (IP or CIDR)




<a id="nestedblock--satori_auth_settings"></a>
### Nested Schema for `satori_auth_settings`

Optional:

- **credentials** (Block List, Max: 1) Root user credentials (see [below for nested schema](#nestedblock--satori_auth_settings--credentials))
- **enable_personal_access_token** (Boolean) Enables Satori Personal Access Token authentication for this data store. to be able using personal access token for authentication on this data store - data store temporary credentials must be enabled and personal access token feature should be enabled for the current account (see Account setting page in Satori platform). Defaults to `false`.
- **enabled** (Boolean) Enables Satori Data Store authentication. Defaults to `false`.

<a id="nestedblock--satori_auth_settings--credentials"></a>
### Nested Schema for `satori_auth_settings.credentials`

Required:

- **password** (String, Sensitive) Password of root user. This property is sensitive, and API does not return it in output. In order to bypass terraform update, use lifecycle.ignore_changes, see example.
- **username** (String) Username of root user

## Example Usage

```terraform
locals {
  dataaccess_controller_id = "<assigned dataaccess_controller_id>"
}

data "satori_data_access_controller" "public_dac" {
  type = "PUBLIC"
  region = "<assigned region>"
  cloud_provider = "<assigned cloud provider>"
}

data "satori_data_access_controller" "private_dac" {
  type = "<assigned type - PRIVATE | PRIVATE_MANAGED>"
  id = "<assigned id>"
}

resource "satori_datastore" "datastore0" {
  name                     = "exampleDatastore"
  hostname                 = "data.source.target.hostname"
  dataaccess_controller_id = local.dataaccess_controller_id
  type                     = "SNOWFLAKE"
  origin_port              = 8081
  baseline_security_policy {
    unassociated_queries_category {
      query_action = "PASS"
    }
    unsupported_queries_category {
      query_action = "PASS"
    }
    exclusions {
    }
  }
  network_policy {}
}

resource "satori_datastore" "datastore_with_ignore_password_update" {
  // lifecycle.ignore_changes should be used after first time creation in order to ignore password update as API does not return it.
  name                     = "exampleDatastore"
  hostname                 = "data.source.target.hostname"
  dataaccess_controller_id = data.satori_data_access_controller.public_dac.id
  type                     = "SNOWFLAKE"
  origin_port              = 8081
  satori_auth_settings {
    enabled = true
    credentials {
      password = "*********"
      username = "adminuser"
    }
  }
  lifecycle {
    ignore_changes = [
      satori_auth_settings.0.credentials.0.password
    ]
  }
  network_policy {}
}

// Example of creating a datastore with personal access token enabled
// Personal access token is used to authenticate with the datastore using a personal access token instead of temporary credentials.
// The personal access token requires the satori_auth_settings to be enabled. and also requires the Personal Access Token feature to be enabled for the account (Account Setting page on Satori platform).
resource "satori_datastore" "datastore_with_personal_access_token_enabled" {
  name                     = "example_datastore_pat_enabled"
  hostname                 = "data.source.target.hostname"
  dataaccess_controller_id = data.satori_data_access_controller.public_dac.id
  type                     = "SNOWFLAKE"
  origin_port              = 8081
  satori_auth_settings {
    enabled = true
    credentials {
      password = "*********"
      username = "adminuser"
    }
    enable_personal_access_token = true
  }
  lifecycle {
    ignore_changes = [
      satori_auth_settings.0.credentials.0.password
    ]
  }
  network_policy {}
}

resource "satori_datastore" "datastore_with_private_dac" {
  // lifecycle.ignore_changes should be used after first time creation in order to ignore password update as API does not return it.
  name                     = "exampleDatastore"
  hostname                 = "data.source.target.hostname"
  dataaccess_controller_id = data.satori_data_access_controller.private_dac.id
  type                     = "SNOWFLAKE"
  origin_port              = 8081
  lifecycle {
    ignore_changes = [
      satori_auth_settings.0.credentials.0.password
    ]
  }
  network_policy {}
}

resource "satori_datastore" "mongodb_datastore" {
  name                     = "mongoExample"
  hostname                 = "mongo.example.mongodb.net"
  dataaccess_controller_id = data.satori_data_access_controller.public_dac.id
  type                     = "MONGO"
  datastore_settings {
    deployment_type = "MONGODB_SRV"
  }
  network_policy {}
}

# output of generated id for newly created datastore
output "datastore_created_id" {
  value = satori_datastore.datastore0.id
}
```
```terraform
locals {
  dataaccess_controller_id = "<assigned dataaccess_controller_id>"
}

resource "satori_datastore" "datastore0" {
  name = "exampleDatastore"

  dataaccess_controller_id = local.dataaccess_controller_id
  # data source specific connection settings
  type                     = "BIGQUERY"
  project_ids              = ["abc", "cdf"] #  BigQuery affected project ids
  hostname                 = "data source target hostname"
  origin_port              = 8081 # data source server's ip
  ####### BASELINE_POLICY SETTINGS #########
  baseline_security_policy {

    unassociated_queries_category {
      query_action = "REDACT" #Allowed: PASS笏コEDACT笏ィLOCK
    }
    unsupported_queries_category {
      query_action = "REDACT"
    }
    exclusions {

      excluded_identities {
        identity_type = "USER"
        identity      = "user1"
      }
      excluded_identities {
        identity_type = "USER"
        identity      = "user2"
      }
      excluded_query_patterns {
        pattern = ".*a.*"
      }
      excluded_query_patterns {
        pattern = ".*b.*"
      }
    }
  }
  network_policy {
    allowed_rules {
      note = "desc1"
      ip_ranges {
        ip_range = "1.1.1.0/24"
      }
      ip_ranges {
        ip_range = "3.2.3.1"
      }
    }
    blocked_rules {
      note = "desc3"
      ip_ranges {
        ip_range = "1.1.1.0/30"
      }
      ip_ranges {
        ip_range = "3.2.3.3"
      }
    }
  }
}


output "datastore_created_id" {
  value = satori_datastore.datastore0.id
}
```
```terraform
locals {
  dataaccess_controller_id = "<assigned dataaccess_controller_id>"
}

resource "satori_datastore" "datastore0" {
  name = "exampleDatastore"

  dataaccess_controller_id = local.dataaccess_controller_id
  # data source specific connection settings
  type                     = "POSTGRESQL"
  hostname                 = "data source target hostname"
  origin_port              = 3532 # data source server's ip
  ####### BASELINE_POLICY SETTINGS #########
  baseline_security_policy {

    unassociated_queries_category {
      query_action = "REDACT" #Allowed: PASS笏コEDACT笏ィLOCK
    }
    unsupported_queries_category {
      query_action = "REDACT"
    }
    exclusions {

      excluded_identities {
        identity_type = "USER"
        identity      = "user1"
      }
      excluded_identities {
        identity_type = "USER"
        identity      = "user2"
      }
      excluded_query_patterns {
        pattern = ".*a.*"
      }
      excluded_query_patterns {
        pattern = ".*b.*"
      }
    }
  }
  network_policy {
    allowed_rules {
      note = "desc1"
      ip_ranges {
        ip_range = "1.1.1.0/24"
      }
      ip_ranges {
        ip_range = "3.2.3.1"
      }
    }
    blocked_rules {
      note = "desc3"
      ip_ranges {
        ip_range = "1.1.1.0/30"
      }
      ip_ranges {
        ip_range = "3.2.3.3"
      }
    }
  }
  satori_auth_settings {
    enabled = true
    credentials {
      password = "*********"
      username = "adminuser"
    }
  }

}


output "datastore_created_id" {
  value = satori_datastore.datastore0.id
}
```

~> **Note: The datastore resource is stateful:** The datastore resource is stateful, deletion or terraform resource name change should be avoided.